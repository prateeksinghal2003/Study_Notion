const User = require("../models/User");
const mailSender = require("../utils/mailSender");
const bcrypt = require("bcryptjs");
const crypto = require("crypto");

exports.resetPasswordToken = async (req, res) => {
	try {

        //get email from request body
        //verify user and email validation
        //generate link using token
        //in User model update the schema ,token and expiration time
        //jo naya token yaha banegaa vo user ke schema pe jaake update kar dooo
        //create a url 
        //send that link to the email
        //return response


		const email = req.body.email;

		//check if user already exist

        const user = await User.findOne({ email: email });

        //is user not found 
		if (!user) {
			return res.json({
				success: false,
				message: `This Email: ${email} is not Registered With Us Enter a Valid Email `,
			});
		}

        //is user found -->generate token
        //using crypto
		const token = crypto.randomBytes(20).toString("hex");

//  crypto: This is a built-in module in Node.js that provides cryptographic functionality.
// randomBytes(20): This function generates a buffer of 20 random bytes. Each byte is 8 bits, 
// so this will generate 160 bits (or 20 bytes) of random data.
// The number 20 is the number of bytes you want to generate. You can adjust this number to get a longer or shorter token.
// These bytes are cryptographically secure and hard to predict, which is why they're often used for token generation.
//
// .toString("hex"): This converts the buffer generated by randomBytes(20) into a hexadecimal string.
// Hexadecimal is a base-16 number system, which represents each byte as two hexadecimal characters.
// This makes the random data more readable and usable as a string.
//160 bits data would be 40 characters long , from 0-9 and A to F, since each hexa digit represents 4 bits

		const updatedDetails = await User.findOneAndUpdate(
			//serach by first parameter
            { email: email },

            //update by second parameter
			{
				token: token,

				//1 hr in milliseconds
				resetPasswordExpires: Date.now() + 3600000,
			},

            //updated document would now be return in response
			{ new: true }
		);
		console.log("DETAILS", updatedDetails);


        //create a front end link using different tokens
        //goal is to generate a new  token for each user
		const url = `http://localhost:3000/update-password/${token}`;


        //now send an mail

		await mailSender(

            //send mailid, title, body
			email,
			"Password Reset",
			`Your Link for email verification is ${url}. Please click this url to reset your password.`
		);
 
         //return response
		res.json({
			success: true,
			message:
				"Email Sent Successfully, Please Check Your Email to Continue Further",
		});
	} catch (error) {
		return res.status(500).json({
			error: error.message,
			success: false,
			message: `Some Error in Sending the Reset Message`,
		});
	}
};




//actual password change
//after clicking on link UI opens up, 
//UI pe naya password dala
//usko receive karke password ko update karna hai
exports.resetPassword = async (req, res) => {
	try {

        //fetch data
        //validation
        //token ka use karke i am fetching user 
        //if no entry for a token -->invalid token or time has expired
        //if user mil gaya
        //naye password ko hash karke,update

        //fetch data
		const { password, confirmPassword, token } = req.body;


        //password validation
		if (confirmPassword !== password) {
			return res.json({
				success: false,
				message: "Password and Confirm Password Does not Match",
			});
		}


       //fetch user details 
		const userDetails = await User.findOne({ token: token });

        //if no entry found 
		if (!userDetails) {
			return res.json({
				success: false,
				message: "Token is Invalid",
			});
		}


        //resetPasswordExpires= currentDate + 1hr

		if (!(userDetails.resetPasswordExpires > Date.now())) {
			return res.status(403).json({
				success: false,
				message: `Token is Expired, Please Regenerate Your Token`,
			});
		}

        //encrypt the password and update in database 
        
		const encryptedPassword = await bcrypt.hash(password, 10);
		await User.findOneAndUpdate(
			{ token: token },
			{ password: encryptedPassword },
			{ new: true }
		);
		res.json({
			success: true,
			message: `Password Reset Successful`,
		});
	} catch (error) {
		return res.json({
			error: error.message,
			success: false,
			message: `Some Error in Updating the Password`,
		});
	}
};